Estimaci칩n de complejidad para Cola de Prioridad
=======================================================================================================================
 public void add(Key elemento) {          
        Node<Key> nuevoNodo = new Node<Key>(elemento);	=> Complejidad O(1) porque es una operaci칩n de asignaci칩n constante. 
        if (root == null) {                             => Complejidad O(1) porque es una asignaci칩n y comparaci칩n simple.
            root = nuevoNodo;                           => Complejidad O(1) porque es una asignaci칩n.
        } else {
            Node<Key> padre = getNode((size + 1) / 2);  => Llamada de m칠todo getNode() con complejidad O(log(n)).
            if (size % 2 == 0) {                        => Complejidad O(1) por comparaci칩n simple.
                padre.right = nuevoNodo;                => Complejidad O(1) por asignaci칩n simple.
            } else {
                padre.left = nuevoNodo;                 => Complejidad O(1) por asignaci칩n simple.
            }
            nuevoNodo.father = padre;                   => Complejidad O(1) por asignaci칩n simple.
        }
        size++;                                         => Se incrementa el atributo size. Complejidad O(1) por asignaci칩n simple.
        siftUp();                                       => Llamada de m칠todo siftUp() con complejidad O(log(n)).
    }

* Debido al Teorema II: 洧녡洧녰 洧냢1 洧녽 洧냢2 洧멇롐럻롐 洧녩洧녳洧녮洧녶洧洧녰洧노洧녴洧녶洧,洧노洧녩洧녳洧뉧롐 洧륋롐뮗롐 洧녢洧냢1(洧녵)洧뉧롐 洧녝(洧녭1(洧녵)) 洧녽 洧녢洧냢2(洧녵)洧뉧롐 洧녝(洧녭2(洧녵)),洧뉧롐 洧노洧녰洧뉧롐뛿롐뢣롐 洧뉧롐洧뉧롐洧뉧롐넗롐뮗롐뫯롐뀛롐洧멇롐뉧롏1 洧멇롐뉧롐덣롐뮗롐뒳롐놿롐 洧녬洧 洧냢2 洧뉧롐 洧녝(max(洧녭1(洧녵), 洧녭2(洧녵))) se puede
afirmar que los bloques de c칩digo que predominar치n sobre la cota asint칩tica superior ser치 O(log(n)), por lo que la complejidad total del m칠todo
void add(key elemento) es O(log(n)).
========================================================================================================================
 public Node<Key> getNode(int index) {
        if (index < 1 || index > size) {                => Complejidad O(1) por comparaci칩n simple ya que index y size deben ser conocidos previamente como constantes.
            return null;                                => Complejidad O(1) por retorno.
        }
        Node<Key> node = root;                          => Complejidad O(1) por asignaci칩n simple.
        int path = index;                               => Complejidad O(1) por asignaci칩n simple.
        int depth = 0;                                  => Complejidad O(1) por asignaci칩n simple.
        while (path > 1) {                              => Se utiliza para hallar la profundidad del 치rbol. Sustentaci칩n en * de esta secci칩n. Complejidad O(log(n)).
            path /= 2;                                  => Complejidad O(1) por asignaci칩n.
            depth++;                                    => Complejidad O(1) por asignaci칩n.
        }                                               => Al utilizar Teorema II en este bloque While se cumple con que el bloque tiene complejidad O(log(n)).
        path = index;                                   => Complejidad O(1) por asignaci칩n.
        for (int i = depth - 1; i >= 0; i--) {          => Se utiliza para recorrer el 치rbol en funci칩n de su profundidad. Debido a esto, su complejidad es O(log(n)).
            if (node == null) {                         => Complejidad O(1) por asignaci칩n.
                return null;                            => Complejidad O(1) por retorno.
            }
            boolean isLeft = ((path >> i) & 1) == 0;    => Complejidad O(1) por asignaci칩n.
            node = isLeft ? node.left : node.right;     => Complejidad O(1) por asignaci칩n
        }
        return node;					=> Complejidad O(1) por asignaci칩n.
    }

* La profundidad (altura) de un 치rbol binario se define a trav칠s de: n = 2^(h+1) - 1, donde n es el n칰mero total de nodos y h es la profundidad o altura del 치rbol.
Por ejemplo, si tenemos un 치rbol con altura 0 quiere decir que tendremos un n칰mero de nodos = 1, que es la ra칤z. Para un 치rbol de altura 1 tendremos un total de
n = 2^(2)-1 nodos, por lo que en el caso ideal en el que est칠 completo este tendr치 3 nodos.
Haciendo un simple proceso de despeje se puede hallar la profundidad de la siguiente manera: 
log(n) = log(2^(h+1)-1)
log(n)=h+1-1 [Ignorando las constantes ya que solo se requiere la cota superior] => h = log(n), claramente el logaritmo en base 2.
Esto quiere decir que para toda operaci칩n que requiera recorrer la profundidad desconocida de un 치rbol binario tendr치 una complejidad en el peor de los casos de
O(log(n)), ya que esto quiere decir que tendr치 que recorrer su altura m치xima para llegar al nodo (caso getNode() y el bucle for que tambi칠n lo necesita).

En todo caso y teniendo en cuenta la aplicaci칩n del Teorema II, la complejidad para el m칠todo getNode() se define como O(log(n)) en el peor de los casos y O(1) en el
mejor de los casos (es el caso donde el nodo que se quiere hallar es la ra칤z).
==================================================================================================
    public Key peek() {
        if (root != null) {                             => Complejidad O(1) por comparaci칩n simple.
            return root.getKey();                       => Complejidad O(1) por retorno.
        }
        return null;                                    => Complejidad O(1) por retorno.
    }

* En conclusi칩n, acorde al Teorema II, la complejidad para el m칠todo peek() se define como O(1) ya que siempre va a retornar la ra칤z del 치rbol, independientemente si es
maxHeap o minHeap, ya que para el maxHeap el elemento mayor se encuentra en la ra칤z, y en el minHeap el elemento menor tambi칠n se encuentra en la ra칤z.
=====================================================================================================
    public Key poll() {
        if (root == null) {                             => Complejidad O(1) por comparaci칩n simple.
            return null;                                => Complejidad O(1) por retorno.
        }
        Key result = root.getKey();                     => Complejidad O(1) por asignaci칩n simple (En el caso del getKey(), se utiliza O(1) por retornar la ra칤z).
        if (size == 1) {
            root = null;                                => Complejidad O(1) por asignaci칩n simple.
        } else {
            Node<Key> lastNode = getNode(size);         => Complejidad O(log(n)) debido a que utiliza getNode() con el tama침o del 치rbol [Ver getNode() en *]
            exch(root, lastNode);                       => Complejidad O(1) porque es un simple intercambio de posiciones entre dos nodos conocidos.
            if (lastNode.father.right == lastNode) {    => Complejidad O(1) por comparaci칩n simple.
                lastNode.father.right = null;           => Complejidad O(1) por asignaci칩n simple.
            } else {
                lastNode.father.left = null;            => Complejidad O(1) por asignaci칩n simple.
            }
        }
        if (root != null) {                             => Complejidad O(1) por comparaci칩n simple.
            siftDown();                                 => Complejidad O(log(n)) porque recorre la altura del 치rbol desde la ra칤z hasta el fondo en el peor de los casos.
        }
        size--;                                         => Complejidad O(1) por asignaci칩n simple.
        return result;                                  => Complejidad O(1) por retorno.
    }

* Acorde al Teorema II, la complejidad para el m칠todo poll() es de O(log(n)) debido a que utiliza el getNode(size) donde el size es el n칰mero de nodos que puede variar,
y el siftDown() que restaura la propiedad de heap al hundir el nodo que viola la regla hasta su posici칩n correcta utilizando el CompareTo().
===========================================================================================================
public void siftUp() {
   Node<Key> node = getNode(size);                             => Complejidad O(log(n)) por utilizar el getNode(size) con un size dependiente del n칰mero de nodos.
   while (node.father != null && less(node.father, node)) {    => Complejidad O(1) por comparaci칩n en ambos lados. En less() es O(1). El bucle de por s칤 tiene O(log(n)).
       exch(node, node.father);                                => Complejidad O(1) por intercambio de posiciones entre dos nodos conocidos.
       node = node.father;                                     => Complejidad O(1) por asignaci칩n simple.
    }
}

* La raz칩n por la cual el bucle While es de complejidad O(log(n)) es la distancia que se maneja desde el nodo encontrado con el m칠todo getNode(size), por lo que 
discretamente depender치 de la profundidad del 치rbol debido a la asignaci칩n del getNode() a node. El nodo seguir치 desplaz치ndose hacia arriba hasta que el compareTo()
deje de permitirlo. En este caso y por el Teorema II, la complejidad del m칠todo siftUp() es O(log(n)).
============================================================================================================
public void siftDown() {
    Node<Key> node = root;                                                                                => Complejidad O(1) por asignaci칩n.
    while (node.left != null) {                                                                           => Complejidad O(log(n)) por recorrido de ra칤z hasta hojas.
       Node<Key> maxChild = (node.right != null && less(node.left, node.right)) ? node.right : node.left; => Complejidad O(1) por comparaci칩n simple.
       if (!less(node, maxChild)) {             						          => Complejidad O(1) por comparaci칩n simple.
            break;
       }
       exch(node, maxChild);										  => Complejidad O(1) por intercambio de nodos.
       node = maxChild;											  => Complejidad O(1) por asignaci칩n simple.
    }
}

* En este m칠todo se utiliza un recorrido desde la ra칤z hasta el nodo correcto (profundidad adecuada) para situar el nodo que se quiere desplazar. El bucle while est치
en funci칩n de esto, as칤 que la complejidad por Teorema II del m칠todo siftDown() ser치 de O(log(n)).
=============================================================================================================
public void agregarPedido(String nombreAutor, double precio, int cercania) {
        Pedido nuevoPedido = new Pedido(precio, nombreAutor, cercania);
        Pedido.comparePorPrecio = true;
        pedidosRecibidos.add(nuevoPedido);
        System.out.println("PEDIDOS RECIBIDOS: " + pedidosRecibidos.toString());
    }

* Al utilizar el add(nuevoPedido) y ser las otras asignaciones de complejidad O(1), agregar un pedido al heap tiene complejidad O(log(n)) debido al an치lisis previo. En
este caso particular, el m칠todo toString() tiene un orden de complejidad de O(nlog(n)) debido a que tiene que recorrer toda la profundidad del heap. En este caso,
recorrer e imprimir todo el heap tiene un orden O(n) ya que se tiene que imprimir cada nodo en su respectivo orden dependiendo a su tama침o, y conseguir la profundidad
del 치rbol para hacerlo es O(log(n)), lo que quiere decir que por Teorema III, la complejidad de agregar pedido SOLAMENTE por esta diferencia de a침adir el toString() 
[A침adir el toString() es completamente opcional] es de O(nlog(n)), siendo similar a como funciona un HeapSort.
==============================================================================================================
 public Pedido atenderPedido() {
        if (pedidosRecibidos.isEmpty() == false) {
            Pedido.comparePorPrecio = true;
            Pedido pedidoAtendido = pedidosRecibidos.poll();
            Pedido.comparePorPrecio = false;
            colaDespachos.add(pedidoAtendido);
            System.out.println("PEDIDOS RECIBIDOS: " + pedidosRecibidos.toString());
            System.out.println("COLA DE DESPACHOS: " + colaDespachos.toString());
            return pedidoAtendido;
        }
        return null;
    }

* La comparaci칩n inicial con isEmpty() es de complejidad O(1). La utilizaci칩n del poll() es de O(log(n)) debido al an치lisis previo, de igual manera que el add() para 
cola de despachos. Esto quiere decir que retirar el elemento m치ximo del heap y a su vez reorganizarlo tendr치 una complejidad O(log(n)) y tambi칠n a침adir al heap de
cola de despachos, con la 칰nica diferencia que lo a침adir치 con un CompareTo invertido (Esto para formar un minHeap en vez de un maxHeap). En este caso al a침adir el
toString() de manera opcional, la complejidad es similar al caso de agregarPedido(), siendo de O(nlog(n)). Sin el uso del toString() seguri치 siendo O(log(n)).
================================================================================================================
 public Pedido despacharPedido() {
        if (colaDespachos.isEmpty() == false) {
            Pedido.comparePorPrecio = false;
            Pedido pedidoDespachado = colaDespachos.poll();
            System.out.println("COLA DE DESPACHOS: " + colaDespachos.toString());
            return pedidoDespachado;
        }
        return null;
    }

* El caso es similar al atender pedido, con la diferencia que el poll() se aplica a la cola de despachos. De igual manera, por el uso del toString() se considera una
complejidad de O(nlog(n)), pero, con el funcionamiento del m칠todo en crudo se considera una complejidad O(log(n)).
=================================================================================================================
  public ArrayList<Pedido> pedidosRecibidosList() {
        ArrayList<Pedido> listaPedidosRecibidos = new ArrayList<>();
        for (int i = 1; i <= pedidosRecibidos.size(); i++) {
            listaPedidosRecibidos.add(pedidosRecibidos.getNodeKey(i));
        }
        return listaPedidosRecibidos;
    }
    public ArrayList<Pedido> colaDespachosList() {
        ArrayList<Pedido> listaDespachos = new ArrayList<>();
        for (int i = 1; i <= colaDespachos.size(); i++) {
            listaDespachos.add(colaDespachos.getNodeKey(i));
        }
        return listaDespachos;
    }

* En el caso de estos dos m칠todos que funcionan exactamente igual, trata de a침adir cada elemento del maxHeap y el minHeap a dos ArrayList distintos. Entonces, se 
presentan dos casos particulares. El bucle for en ambos casos va desde el 칤ndice 1 hasta el tama침o del heap, que al ser desconocido es de tama침o n, dando as칤 una
complejidad O(n) 칰nicamente para el bucle for. En cuanto al contenido de ambos, llama a un m칠todo que se llama getNodeKey(i) que es el siguiente:

 public Key getNodeKey(int index) {
        Node<Key> node = getNode(index);
        if (node != null) {
            return node.getKey();
        }
        return null;
    }

* Este m칠todo lo que hace es llamar a su vez a getNode(index), que tiene una complejidad O(log(n)) ya que dependiendo al index que se le pase como par치metro tendr치 que
recorrer la profundidad del 치rbol. En tal caso, getNodeKey(index) tendr치 complejidad m치xima de O(log(n)) debido al teorema II.
Debido a que el contenido de ambos for utiliza este getNodeKey(index) y tambi칠n el for tiene su propia complejidad que no es constante, entonces se utilizar치 el
Teorema III, con el que en ambos m칠todos que utilicen el ArrayList se tendr치 una complejidad de O(nlog(n)), similar a un HeapSort.
